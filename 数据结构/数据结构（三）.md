---
title: 数据结构（三）
date: 2023-11-02 21:46:16
top_image: https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101557569.png
cover: https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101557569.png
tags:
- [线性表]
- [单链表]
- [静态链表]
- [循环链表]
- [双向循环链表]
categories: 
- [数据结构]
- [文章]
---

# 第三章 线性表
## <font color="886600">3.1 线性表的定义</font>
<strong>定义：线性表是0或多个数据元素的有限序列</strong>
- 若将线性表记为{a<sub>1</sub>,…,a<sub>i-1</sub>,a<sub>i</sub>,a<sub>i+1</sub>,…,a<sub>n</sub>}，则a<sub>i-1</sub>是a<sub>i</sub>的<font color = "CC6600">「直接前驱元素」</font>，a<sub>i+1</sub>是a<sub>i</sub>的<font color = "CC6600">「直接后继元素」</font>。除第一个元素外其余元素有且只有一个直接前驱元素，除最后一个元素外其余元素有且只有一个直接后继元素。
- 在线性表中，n（n $\geq$ 0）为线性表的长度，当n=0时称为<font color = "CC6600">「空表」</font>
- 在非空线性表中每个元素都有一个确定的位置，如a<sub>1</sub>是第一个元素，a<sub>i-1</sub>是第i-1个位置，a<sub>i</sub>是第i个元素，我们称i为数据元素a<sub>i</sub>在线性表中的<font color = "CC6600">「位序」</font>
- 在较为复杂的线性表中，一个数据元素可能会由多个数据项组成。（例如我们创建一个学生类（数据元素），这个学生类可能有“姓名”“年龄”“性别”“生日”“学号”等等属性（数据项），这些属性（数据项）共同组成一个类（数据元素）
## <font color="886600">3.2 线性表的抽象数据类型</font>
创建线性表的抽象数据类型首先要明确它具有哪些操作，最基本的就是CRUD，扩展的一些就是清空和排序：
```C#
ADT 线性表（MyList）
Data
	线性表的数据集合为{a1,a2,…,an}，每个数据元素的数据类型均为DataType，除第一个元素无直接前驱元素外其余每个元素有且只有一个直接前驱元素，除最后一个元素无直接后继元素外其余每个元素有且只有一个直接后继元素。线性表中的数据元素是一对一的关系。
Operation
	InitList()：初始化操作
	Add(T data)：在线性表末尾添加一个元素
	Insert(int i,T data)：在指定位序中插入一个元素
	Dilatation()：对线性表进行扩容
	Delete(T data)：删除指定元素
	DeleteAt(int index)：删除指定位序的元素
	Get(int i)：获取指定位序的元素
	Length()：获取线性表当前的元素总数
	Count()：获取线性表当前的长度
	Clear()：清空线性表
endADT
```
## <font color="886600">3.3 线性表的顺序存储结构</font>
<strong>定义：线性表的顺序存储结构就是将线性表中的数据存储在一段地址连续的存储单元中</strong>
### <font color="AA7700">3.3.1 顺序存储方式</font>
关于线性表顺序存储方式的实现我们可以采用<font color="CC6600">「一维数组」</font>来实现，而实现顺序存储结构需要三个属性：
- 存储空间的起始位置：数组 data ，它的存储位置就是存储空间的存储位置
- 线性表的最大存储容量：数组的长度 MaxSize
- 线性表的当前长度：数据元素的个数 Length

“线性表的最大存储容量”和“线性表的当前长度”的区别：
- “线性表的最大存储容量”即为数组的长度，它是用来存放线性表的存储空间，这个量在一开始就决定好了，一般不能改变
- “线性表的当前长度”也就是当前的线性表存放了多少数据元素，它是会随着数据元素的增加和删除动态改变的，但是无论它怎么改变都不会大于“线性表的最大存储容量”
### <font color="AA7700">3.3.2 顺序存储方式的优点和缺点</font>
优点：
- 无须为表示表中元素的逻辑结构而增加额外的空间
- 可以快速的存取表中任一位置的元素（时间复杂度为O(1))

缺点：
- 插入和删除操作需要移动大量元素（时间复杂度为O(n)）
- 当线性表长度变化较大时，难以确定存储空间的容量。而频繁的扩容又容易导致内存“碎片”的产生

### <font color="AA7700">3.3.3 地址计算方法</font>
<strong>定义：存储器中的每个存储单元都有属于自己的编号，这个编号就是地址</strong>
- 计算方法：假设我们存储一个数据元素需要占据 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的存储位置满足下列关系（Loc表示获得存储位置的函数）：<font style = "background : #FFBB00">Loc(a<sub>i+1</sub>)=Loc(a<sub>i</sub>)+c</font>。所以对于第 i 个数据元素的存储位置，我们可以由a<sub>1</sub>获得：<font style = "background : #FFBB00">Loc(a<sub>i</sub>)=Loc(a<sub>1</sub>)+(i-1)×c</font>

我们可以根据这个公式随时算出某个数据元素在线性表中的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入（即添加在线性表的末尾）和取出都是相同的时间，即为一个常数，所以它的时间复杂度是O(1)。我们通常把具有这一特点的存储结构称为<font color = "CC6600">「随机存储结构」</font> ^fd4866
### <font color="AA7700">3.3.3 利用C#代码实现线性表的顺序存储结构</font>
![线性表_顺序存储结构_代码思维导图.png](https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101557148.png)
```C#
public class Student
{
    public string Name { get; set; }
    public int Age { get; set; }
    public int Id { get; set; }

    public Student(string name,int age,int id)
    {
        Name = name;
        Age = age;
        Id = id;
    }
}

public interface IMyList<T>
{
    T this[int index]
    {
        get;
        set;
    }

    void Add(T item);
    void Insert(int index, T item);
    void Grow();
    bool Remove(T item);
    void RemoveAt(int index);
    int IndexOf(T item);
}

public class MyList<T>:IMyList<T>
{
    private const int _defaultCapacity = 4;//默认容量
    private int _count;//实际元素个数

    private T[] _array;//存放元素的数组
    private readonly T[] _emptyArray = Array.Empty<T>();//空数组

    public int Count => _count;//获取线性表中当前的元素个数
    /// <summary>
    /// 设置或获取当前集合的容量
    /// </summary>
    public int Capacity
    {
        get => _array.Length;
        set
        {
            if(value < _count)
                throw new ArgumentOutOfRangeException(nameof(value),"容量不能小于元素个数");

            if (value != _array.Length)
            {
                if (value > 0)
                {
                    T[] newArray = new T[value];
                    if (_count > 0)
                    {
                        for (int i = 0; i < _count; i++)
                        {
                            newArray[i] = _array[i];
                        }

                        _array = newArray;
                    }
                    else
                        _array = newArray;
                }
            }
        }
    }
    public MyList() //初始化操作，默认为空数组
    {
        _array = _emptyArray;
    }

    /// <summary>
    /// 初始化操作，指定容量
    /// </summary>
    /// <param name="capacity">指定的容量大小</param>
    /// <exception cref="ArgumentOutOfRangeException">如果指定的容量小于0应当抛出异常</exception>
    public MyList(int capacity)
    {
        if (capacity < 0)
            throw new ArgumentOutOfRangeException(nameof(capacity), "容量不能小于0");

        _array = capacity == 0 ? _emptyArray : new T[capacity];
    }

    /// <summary>
    /// 将别的集合中的元素复制到当前集合中
    /// </summary>
    /// <param name="collection">源集合</param>
    /// <exception cref="ArgumentNullException">如果源集合为空则抛出异常</exception>
    public MyList(IEnumerable<T> collection)
    {
        if(collection == null)
            throw new ArgumentNullException(nameof(collection),"源集合不能为空");

        if (collection is ICollection<T> c)
        {
            int count = c.Count;

            if (count == 0)
                _array = _emptyArray;
            else
            {
                _array = new T[count];
                for (int i = 0; i < count; i++)
                {
                    _array[i] = c.ElementAt(i);
                }

                _count = count;
            }
        }
        else
        {
            _array = _emptyArray;
            using IEnumerator<T> enumerator = collection.GetEnumerator();
            while (enumerator.MoveNext())
            {
                Add(enumerator.Current);
            }
        }
    }

    /// <summary>
    /// 循环获取元素或者用于循环设置元素
    /// </summary>
    /// <param name="index">需要获取或修改元素的位序</param>
    /// <returns></returns>
    /// <exception cref="ArgumentOutOfRangeException">当位序超过索引范围时应抛出异常</exception>
    public T this[int index]
    {
        get
        {
            if (index < 0 || index >= _count)
                throw new ArgumentOutOfRangeException(nameof(index), "索引超出范围");

            return _array[index];
        }
        set
        {
            if (index < 0 || index >= _count)
                throw new ArgumentOutOfRangeException(nameof(index), "索引超出范围");

            _array[index] = value;
        }
    }

    /// <summary>
    /// 向线性表中添加数据元素
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public void Add(T item)
    {
        int count = _count;
        T[] array = _array;

        if (count < array.Length)
        {
            array[count++] = item;
            _count = count;
        }
        else
        {
            Grow();
            _array[count++] = item;
            _count = count;
        }
    }

    /// <summary>
    /// 插入操作
    /// </summary>
    /// <param name="index">插入索引</param>
    /// <param name="item">插入元素</param>
    /// <exception cref="ArgumentOutOfRangeException">当插入的索引不在范围之内抛出异常</exception>
    public void Insert(int index, T item)
    {
        if (index < 0 || index > _count)
            throw new ArgumentOutOfRangeException(nameof(index),"索引必须在范围之内");

        if (_count == _array.Length)
            Grow();

        T[] array = _array;
        T[] newArray = new T[array.Length];

        for (int i = 0; i < index; i++)
        {
            newArray[i] = array[i];
        }

        newArray[index] = item;
        for (int i = index + 1; i < newArray.Length; i++)
        {
            newArray[i] = array[i - 1];
        }

        _array = newArray;
        _count++;
    }

    /// <summary>
    /// 当集合容量不足时，扩容
    /// </summary>
    public void Grow()
    {
        int newCapacity = _array.Length == 0 ? _defaultCapacity : _array.Length * 2;

        if(newCapacity > Array.MaxLength)
            newCapacity = Array.MaxLength;

        Capacity = newCapacity;
    }

    /// <summary>
    /// 删除指定元素
    /// </summary>
    /// <param name="item">需要删除的元素</param>
    /// <returns></returns>
    /// <exception cref="ArgumentNullException">如果删除的元素为null则抛出异常</exception>
    public bool Remove(T item)
    {
        if(item == null) 
            throw new ArgumentNullException(nameof(item),"删除元素不能为null");

        int index = IndexOf(item);
        if (index >= 0)
        {
            RemoveAt(index);
            return true;
        }

        return false;
    }

    /// <summary>
    /// 根据索引删除元素
    /// </summary>
    /// <param name="index">需要删除元素的索引</param>
    public void RemoveAt(int index)
    {
        T[] newArray = new T[_array.Length];
        T[] array = _array;

        if (index < 0 || index >= _count)
            throw new ArgumentOutOfRangeException(nameof(index), "索引超出范围");

        for (int i = 0; i < index; i++)
        {
            newArray[i] = array[i];
        }

        for (int i = index; i < array.Length-1; i++)
        {
            newArray[i] = array[i + 1];
        }

        _array = newArray;
        _count--;
    }

    /// <summary>
    /// 用于获取指定元素的位序
    /// </summary>
    /// <param name="item">需要获取位序的元素</param>
    /// <returns>返回位序</returns>
    public int IndexOf(T item)
        =>Array.IndexOf(_array, item);
}

namespace MyList
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyList<Student> students = new();
            List<int> list = new();

            Student s1 = new("张三", 18, 1);
            Student s2 = new("李四", 19, 2);
            Student s3 = new("王五", 20, 3);
            Student s4 = new("赵六", 21, 4);
            Student s5 = new("孙七", 22, 5);
            Student s6 = new("周八", 23, 6);
            Student s7 = new("吴九", 24, 7);
            Student s8 = new("郑十", 25, 8);

            students.Add(s1);
            students.Add(s2);
            students.Add(s3);
            students.Add(s4);
            students.Add(s5);
            students.Add(s6);
            students.Add(s7);
            students.Add(s8);

            students.Insert(8,s1);
            students.Insert(8,s1);
            students.Insert(8,s1);
            students.Insert(8,s1);
            students.RemoveAt(1);
            for (int i = 0; i < students.Count; i++)
            {
                Console.WriteLine(students[i].Name);
            }
        }
    }
}
```
这种思维模式是我在阅读.Net相关源码（System.Collections.Generic.List\<T\>)学习到的。其实我也按照自己最初的想法写过一遍也成功实现了，但是就感觉没有它的那么有逻辑性和安全性于是我就查阅了.Net相关部分的源码，发现写的真好啊，于是就结合自己的想法复刻了一下，下面是我在编码过程中的一些思考：
- 三个初始化针对不同的需求
	- 第一个构造函数：在初始化完之后可能不会立马用到，甚至它的出现只是一时脑抽造成的，那么这个时候不应该立马分配内存空间，所以这个只是声明一下并没有分配实际的内存空间，等实际需要用的时候再分配，可以防止内存浪费
	- 第二个构造函数：当我们明确知道这个线性表需要存储多少数据元素时我们就可以用这个构造函数。因为在这里线性表的默认长度是4，一旦超过默认长度它就会动态扩容，而动态扩容又容易造成内存碎片，所以当我们明确知道需要多长时就可以用这个构造函数。
	- 第三个构造函数：……
- Capacity：用于获取和设置线性表的容量。单独写一个属性的好处就是可以复用，我们在Add和Insert时如果容量不足那么都可以用Capacity进行扩容，而且有时也有重新设置线性表容量的需求
- this[int index]：索引器，用于像数组那样可以循环
- Add：先将实例字段_count、\_array赋值给局部变量有两个好处，一是可以提高代码的性能和效率，因为每次调用实例字段都需要从内存中读取他们的值，这会消耗一定的时间和资源。而如果将它们赋值给变量，那么它们的值就会缓存到局部变量中，之后的读取就可以直接从局部变量中读取值这样可以减少内存的访问次数，提高代码的运行速度。二是可以避免潜在的错误。如果我们有多线程的需求，那么实例字段的值可能会被其他线程或者方法修改，导致数据的不一致或者越界。但是如果将它们缓存到局部变量中，那么久可以保证在执行代码的过程中值不会被改变，从而保证数据的一致性和安全性。
- Grow：在将newCapacity赋值完之后还对newCapacity进行了一个判断，因为数组是有存储上限的，而我们扩容又是成倍扩容所以比较容易造成内存外溢，因此需要判断一下扩容之后的长度是否在最大长度范围之内。
## <font color="886600">3.4 线性表的链式存储结构</font>
<strong>定义：链式存储结构是采用一组任意的存储单元来对数据元素进行存储，这一组存储单元可以是连续的也可以是不连续的。</strong></br>
<strong>在顺序存储结构中我们只需要存储数据元素本身，但是在链式结构中我们不仅需要存储数据元素本身的信息还需要存储后继数据元素的存储地址，因此我们把存储数据元素本身信息的域称为<font color = "CC6600">「数据域」。</font></strong></br>
<strong>把存储后继数据元素的地址的域称为<font color = "CC6600">「指针域」</font>，指针域中的信息称为<font color = "CC6600">「指针」</font>或<font color = "CC6600">「链」</font>，由数据域和指针域共同组成的叫做<font color = "CC6600">「结点」（Node)</font></strong>
## <font color="886600">3.5 单链表</font>
- <strong>定义：n个结点链接而成的一个链表，即为线性表（a<sub>1</sub>、a<sub>2</sub>、……、a<sub>i</sub>）的链式存储结构，因为该链表的每个结点都只包含一个指针域，所以叫做<font color = "CC6600">「单链表」</font></strong>
- <strong>我们把指向第一个结点（如果有头结点那就指向头结点）的指针叫做<font color = "CC6600">「头指针」</font></strong>
- <strong>在单链表的第一个结点前附设的一个结点叫做<font color = "CC6600">「头结点」，</font>头结点中的指针域指向第一个正式结点，而数据域则不存储任何信息</strong>

### <font color = "AA7700">3.5.1头指针和头结点的异同</font>
头指针：
- 头指针是指链表指向第一个结点的指针，如果链表有头结点则是指向头结点的指针
- 头指针具有标志作用，所以常用头指针冠以链表的名字
- 无论链表是否为空，头指针均不为空。头指针是链表的必要元素

头结点：
- 头结点是为了操作统一和方便而设立的，放在第一结点之前，其数据域一般无意义。指针域存储的是第一结点的地址信息
- 有了头结点，针对第一结点前的插入和删除第一结点的操作就与其他结点的操作统一了
- 头结点不是链表的必要元素
### <font color = "AA7700">3.5.2单链表的获取</font>
- 声明一个Node，指向链表第一个结点，初始化j从1开始（j从1开始是因为头结点也包含在链表当中）
- 当j<i时，就遍历整个链表，让p的指针向后移动，不断指向下一个结点,j累计1
- 若到链表末尾Node为空，则说明第i个结点不存在
- 否则查找成功，返回获取的值

因为单链表的获取是需要从头开始遍历，因此它的时间复杂度为O(n)；
### <font color = "AA7700">3.5.3单链表的插入和删除</font>
插入operation：
- 声明一个Node，指向链表的头结点，初始化j从1开始
- 当j<i时，就遍历链表，让指针p向后移动，不断指向下一个结点
- 若到链表末尾Node为空，则说明第i个结点不存在
- 否则查找成功，在系统中生成一个空结点s
- 将数据元素e赋值给s->data
- 单链表的插入标准语句是：s->next=p->next，p->next=s；
- 返回成功

删除operation：
- 声明一个结点p，指向链表的头结点，j初始化为1；
- 当j<i-1时遍历整个链表，让p的指针向后移动，不断指向下一个结点，j累加1；
- 若到链表末尾p为空，则说明第i个结点不存在，返回失败
- 否则查找成功，将查找成功的那个结点 p->next赋值给新结点q
- 单链表标准的删除语句：p->next = q.next
- q = null
- 返回成功

对于单链表插入和删除操作的时间复杂度其实并不是如网上的部分教程上所说为O(1)，其实单链表在大部分时候它的插入和删除操作的时间复杂度都是为O(n)，因为插入和删除也是需要通过遍历来查找特定的结点。也就只有当插入操作在开头和末尾、删除操作在开头它们的时间复杂度才是O(1)。当然，我们也可以采用空间换时间的思想，将之前查找过的元素的地址缓存起来，那么当我们下一次查询时就能直接获取该元素的地址，这样就能达到时间复杂度是O(1)
### <font color = "AA7700">3.5.4头插法</font>
- 声明一个结点p和计数器变量i；
- 初始化一空链表L；
- 让L的头结点的指针指向null，即建立一个带头结点的单链表；
- 循环：
	- 生成一新结点赋值给p；
	- 将数据赋值给p的数据域p->data；
	- 将p插入到头结点与第一结点之间
### <font color = "AA7700">3.5.5尾插法</font>
- 声明一个结点r和计数器变量i，其中r始终指向链表末尾
- 初始化一空链表L；
- 让L的头结点的指针指向r
- 循环：
	- 声明一个新结点p；
	- 将数据赋值给p的数据域p->data；
	- r=p；
- r->next = null;
### <font color = "AA7700">3.5.6整表删除</font>
- 声明一个结点p和q
- 将第一个结点赋值给p，p=head.next；
- 循环：
	- q=p->next；
	- p=q；
- head.next=null；
### <font color = "AA7700">3.5.6单链表结构与顺序存储结构的优缺点</font>
存储分配方式：
- 顺序存储结构是用一段连续的存储单元依次存储线性表中的数据元素
- 单链表采用链式存储结构，用任意一组存储单元来存储线性表中你的数据元素，这一组存储单元可以是连续的也可以是不连续的

时间性能：
- 查找
	- 顺序存储结构为O(1)
	- 单链表O(n)
- 插入和删除
	- 顺序存储结构需要平均移动表长一半的元素，时间复杂度为O(n)
	- 单链表在查找出位置的指针后，插入和删除操作的时间复杂度为O(1)

空间性能
- 顺序存储结构需要预分配存储空间，分大了，浪费，分小了又容易发生上溢
- 单链表不需要分配存储空间，只要有空间就可以分配，元素个数也不受限制

因此，我们可以得出：<font color = "CC6600">「若线性表需要频繁的查找，很少进行插入和删除操作时，宜采用顺序存储结构；若线性表需要进行频繁的插入和删除操作，且无法确定元素个数的变化情况，则采用单链表结构。」</font>
### <font color = "AA7700">3.5.7使用C#实现单链表</font>
```C#
public interface IMyLinkedList<T>
{
    /// <summary>
    /// 使链表能像数组一样循环访问
    /// </summary>
    /// <param name="index">位序</param>
    /// <returns>返回数据元素</returns>
    T this[int index] { get; set; }

    /// <summary>
    /// 将指定元素添加到链表开头（头结点之后一个）
    /// </summary>
    /// <param name="item">需要添加的元素</param>
    void AddFirst(T item);

    /// <summary>
    /// 将指定的元素添加到链表(默认添加到链表末尾）
    /// </summary>
    /// <param name="item">需要添加的元素</param>
    void Add(T item);

    /// <summary>
    /// 将元素插入链表指定位置
    /// </summary>
    /// <param name="index">需要插入的位置</param>
    /// <param name="item">需要插入的数据元素</param>
    bool Insert(int index, T item);

    /// <summary>
    /// 删除链表第一个结点
    /// </summary>
    /// <returns>删除成功返回true</returns>
    bool RemoveFirst();

    /// <summary>
    /// 删除链表最后一个结点
    /// </summary>
    /// <returns>删除成功返回true</returns>
    bool RemoveLast();

    /// <summary>
    /// 删除指定位序的结点
    /// </summary>
    /// <param name="index">需要删除结点处的位序</param>
    /// <returns>删除成功返回true</returns>
    bool Remove(int index);
}

public class Node<T>
{
#pragma warning disable CS8618
    public T Data { get; set; }
#pragma warning restore CS8618
    public Node<T>? Next { get; set; } = null;
} 

public class MyLinkedList<T> : IMyLinkedList<T>
{
    private readonly Node<T> _head; //头结点
    private int _count; //元素个数

    public MyLinkedList()
    {
        _head = new();
        _count = 0;
    }

    public int Count => _count;

    /// <summary>
    /// 使链表能像数组一样循环访问或者修改数据元素
    /// </summary>
    /// <param name="index">位序</param>
    /// <returns>返回数据元素</returns>
    public T this[int index]
    {
        get
        {
            if(index < 0 || index > Count)
                throw new IndexOutOfRangeException(nameof(index));

            Node<T>? node = _head;

            for (int i = 1; i <= index+1; i++)
            {
                node = node.Next ?? throw new IndexOutOfRangeException(nameof(index));
            }
            return node.Data;
        }
        set
        {
            if (index < 0 || index > Count)
                throw new IndexOutOfRangeException(nameof(index));

            Node<T> node = _head;
            for (int i = 1; i <= index+1; i++)
            {
                node = node.Next ?? throw new IndexOutOfRangeException(nameof(index));
            }

            node.Data = value;
        }
    }

    /// <summary>
    /// 将指定元素添加到链表开头（头结点之后一个）
    /// </summary>
    /// <param name="item">需要添加的元素</param>
    public void AddFirst(T item)
    {
        if(item is null)
            throw new ArgumentNullException(nameof(item));

        Node<T> head = _head;
        Node<T> node = new()
        {
            Next = head.Next,
            Data = item
        };
        head.Next = node;
        _count++;
    }

    /// <summary>
    /// 将指定的元素添加到链表（默认添加到末尾）
    /// </summary>
    /// <param name="item">需要添加的元素</param>
    public void Add(T item)
    {
        if(item is null)
            throw new ArgumentNullException(nameof(item));

        Node<T>? node = _head;
        while (node.Next != null)
        {
            node = node.Next;
        }

        if (node.Next is null)
        {
            Node<T> newNode = new()
            {
                Data = item,
                Next = null
            };

            node.Next = newNode;
            _count++;
        }
    }

    /// <summary>
    /// 将元素插入链表指定位置
    /// </summary>
    /// <param name="index">需要插入的位置</param>
    /// <param name="item">需要插入的数据元素</param>
    public bool Insert(int index, T item)
    {
        if(index < 0 || index >Count)
            throw new IndexOutOfRangeException(nameof(index));

        if(item is null)
            throw new ArgumentNullException(nameof(item));

        int i = 1;
        Node<T>? node = _head;
        while (node != null && i < index)
        {
            node = node.Next;
            i++;
        }

        if (node is null || i > index)
            return false;

        Node<T> newNode = new()
        {
            Data = item,
            Next = node.Next
        };

        node.Next = newNode;
        return true;
    }

    /// <summary>
    /// 删除链表第一个结点
    /// </summary>
    /// <returns>删除成功返回true</returns>
    public bool RemoveFirst()
    {
        Node<T> node = _head;
        if (node.Next is null)
            return false;

        Node<T> deleteNode = node.Next;
        node.Next = deleteNode.Next;

        _count--;
        return true;
    }

    /// <summary>
    /// 删除链表最后一个结点
    /// </summary>
    /// <returns>删除成功返回true</returns>
    public bool RemoveLast()
    {
        if (!RemoveAt(Count))
            return false;

        _count--;
        return true;
    }

    /// <summary>
    /// 删除指定位序的结点
    /// </summary>
    /// <param name="index">需要删除结点处的位序</param>
    /// <returns>删除成功返回true</returns>
    public bool Remove(int index)
    {
        if (index < 0 || index > Count)
            return false;

        if (!RemoveAt(index))
            return false;

        _count--;
        return true;
    }

    private bool RemoveAt(int index)
    {
        Node<T> node = _head;

        int i = 1;
        while (node.Next != null && i < index + 1)
        {
            node = node.Next;
            i++;
        }

        if (node.Next is null || i > index + 1)
            return false;

        Node<T> deleteNode = node.Next;
        node.Next = deleteNode.Next;

        return true;
    }
}

namespace MyLinkedList
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyLinkedList<int> list = new();
            Console.WriteLine($"初始化后的长度为：{list.Count}");

            for (int i = 0; i < 6; i++)
            {
                list.Add(i);
            }
            Console.WriteLine($"利用Add方法添加元素之后的长度为：{list.Count}");

            Console.Write("利用索引器获取元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],2}");
            }

            Console.Write($"\n利用索引器对现有的元素进行修改：");
            for (int i = 0; i < list.Count; i++)
            {
                list[i] = i + 1;
                Console.Write($"{list[i],2}");
            }

            Console.Write($"\n尝试将元素插入表头：");
            for (int i = 10; i < 20; i++)
            {
                list.AddFirst(i);
            }
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],3}");
            }

            list.Insert(4, 444);
            list.Insert(2, 222);
            Console.Write($"\n尝试在第2、4处插入元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            for (int i = 0; i < 5; i++)
            {
                list.Remove(1);
            }
            list.Remove(6);
            Console.Write($"\n删除后的元素有：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],4}");
            }

            list.RemoveFirst();
            list.RemoveLast();
            Console.Write($"\n利用RemoveFirst和RemoveLast方法删除元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],4}");
            }
        }
    }
}


```
由于在单链表中头结点也包含在里面，所以对于循环一般是将i初始化为1，这样就可以直接从实际的结点开始。这样子的话第1个元素实际就是第2个元素，第2个元素就是第3个元素，所以如果我们要获取第5个元素，那么i应该小于等于（下标+1），即：i<=(4+1)，因为第5个元素的小标对应4。因为多了一个头结点所以第一个元素对应的小标就是1，第2个元素对应的下标就是2，以此类推。
## <font color="886600">3.6 静态链表</font>
- <strong>定义：用数组描述的链表的叫做静态链表</strong>
	- 数组的元素都是由两个数据域组成的：data和cur。data用来存放数据，cur用来存放后继元素的下标，我们通常将cur称为游标
	- 我们对数组的第一个元素和最后一个元素作特殊处理，不存数据。将第一个元素的data不存数据，而cur存放备用链表^[备用链表：我们通常把未使用的数组元素称为备用链表]中的第一个元素的下标。而最后一个数组元素的cur通常用来存放第一个有数值的数组元素的下标，相当于头结点，如果整个链表为空，则为0
	- 最后一个实际存放数据信息的数组元素的cur为0
### <font color = "AA7700">3.6.1静态链表的插入</font>
- 静态链表中要解决的问题是：如何用静态模拟动态链表结构的存储空间分配，需要时申请，不需要时释放
- 解决办法就是将所有未被使用的或已经被删除的分量用游标链成一条备用链表，每当进行插入时，便可以从备用链表上获取第一个结点作为待插入的新结点

| index |    0    |  1   |    2    |  3   |  4   |  5   |  6   |               7               |  8   |  9   |
| :---: | :-----: | :--: | :-----: | :--: | :--: | :--: | :--: | :---------------------------: | :--: | :--: |
| data  |         |  甲  |   乙    |  丁  |  戊  |  己  |  庚  | <font color = "red">丙</font> |      |      |
|  cur  | ~~7~~ 8 |  2   | ~~3~~ 7 |  4   |  5   |  6   |  0   |            ~~8~~ 3            |  9   |  1   |

假设我们需要在第3个位置插入“丙”元素（初始条件：已经初始化了一个数组item）：
- 首先通过备用链表获取第一个空闲的数组元素的cur：int index = item[0].Cur;---> index = 7
- 将“丙”插入第8个数组元素：item[7].Data = "丙";
- 修改第一个数组元素的cur：item[0].Cur = item[7].Cur;
- 修改第8个数组元素的cur：item[index].Cur = item[2].Cur;
- 修改第3个数组元素的cur：item[2].Cur = index;
- 完毕
### <font color = "AA7700">3.6.2静态链表的删除</font>
| index |    0    |  1   |  2   |    3    |  4   |  5   |  6   |               7               |  8   |  9   |
| :---: | :-----: | :--: | :--: | :-----: | :--: | :--: | :--: | :---------------------------: | :--: | :--: |
| data  |         |  甲  |  乙  |  null   |  戊  |  己  |  庚  | <font color = "red">丙</font> |      |      |
|  cur  | ~~8~~ 3 |  2   |  7   | ~~4~~ 8 |  5   |  6   |  0   |            ~~3~~ 4            |  9   |  1   |

现在假设我们需要删除第4个元素，也就是丁：
- 获取第4个元素的cur：int cur = item[3].Cur; ---> 4
- 将第4个数组元素的data改为null：item[3].Data = null;
- 将第4个数组元素的cur修改为备用链表第一个数组元素的index：item[3].Cur = item[0].Cur;
- 将第一个数组元素的cur修改为第7个数组元素的cur：item[0].Cur = item[7].Cur；
- 将第7个数组元素的cur修改为4：item[7].Cur = cur;
- 完毕
### <font color = "AA7700">3.6.3实现代码</font>
```C#
public class Node<T>
{
# pragma warning disable CS8618
    public T Data { get; set; }
#pragma warning restore CS8618
    public int Cur { get; set; }
}

public interface IMyStaticLinkedList<T>
{
    T this[int index] { get; set; }
    bool Add(T item);
    void AddFirst(T item);
    void Insert(int index, T item);
    bool Remove(T item);
    bool RemoveAt(int index);
}

public class MyStaticLinkedList<T> : IMyStaticLinkedList<T>
{
    private Node<T>[] _items;
    private readonly Node<T>[] _emptyNode = Array.Empty<Node<T>>();

    private readonly int _spare = 0;//备用链表的头结点位置
    private int _count;//数组中含有的数据元素个数
    private const int _defaultCapacity = 10;//数组大小默认为10

    public MyStaticLinkedList()
    {
        _items = _emptyNode;
        _count = 0;
    }

    public MyStaticLinkedList(int capacity)
    {
        if(capacity < 0)
            throw new ArgumentOutOfRangeException(nameof(capacity),"初始化容量不能小于0");
        if (capacity > Array.MaxLength)
            throw new IndexOutOfRangeException(nameof(capacity));

        _items = new Node<T>[capacity];
        for (int i = 1; i < capacity - 1; i++)
        {
            _items[i].Cur = i + 1;
        }

        _items[_spare].Cur = 1;
        _items[capacity - 1].Cur = 0;

        _count = 0;
    }
    public int Count => _count;

    /// <summary>
    /// 获取或设置数组的容量
    /// </summary>
    public int Capacity
    {
        get=>_items.Length;
        set
        {
            if (value < _count || value > Array.MaxLength)
                throw new ArgumentOutOfRangeException(nameof(value), "索引超出数组范围");

            if (value != _items.Length)
            {
                Node<T>[] items = _items;
                Node<T>[] newItems = new Node<T>[value];
                if (_count != 0)
                {
                    int length = items.Length;

                    //初始化新增数组元素的cur值
                    for (int i = length-1; i < value - 1; i++)
                    {
                        newItems[i] = new()
                        {
                            Cur = i + 1
                        };
                    }

                    //将旧数据元素复制到新数组中
                    for (int i = 0; i < length-1; i++)
                    {
                        newItems[i] = items[i];
                    }

                    newItems[^1] = items[^1];//设置新数组的尾结点
                }
                else
                {
                    for (int i = 0; i < newItems.Length - 1; i++)
                    {
                        newItems[i] = new()
                        {
                            Cur = i + 1
                        };
                    }

                    newItems[^1] = new()
                    {
                        Cur = 0
                    };
                }

                _items = newItems;
            }
        }
    }

    /// <summary>
    /// 获取或修改数据信息
    /// </summary>
    /// <param name="index">位序</param>
    /// <returns></returns>
    /// <exception cref="IndexOutOfRangeException">如果索引超出范围则抛出异常</exception>
    public T this[int index]
    {
        get
        {
            if (index < 0 || index > Count)
                throw new IndexOutOfRangeException(nameof(index));

            int cur = _items[^1].Cur;
            for (int i = 1; i < index + 1; i++)
            {
                cur = _items[cur].Cur;
            }

            return _items[cur].Data;
        }
        set
        {
            if (index < 1 || index > _count)
                throw new IndexOutOfRangeException(nameof(index));

            Node<T>[] items = _items;

            int cur = items[^1].Cur;
            for (int i = 1; i < index+1; i++)
            {
                cur = items[cur].Cur;
            }

            items[cur].Data = value;
        }
    }


    /// <summary>
    /// 默认添加到数组的末尾
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public bool Add(T item)
    {
        if (_count >= _items.Length - 2)
            Grow();

        int spare = _spare;
        int count = _count;
        Node<T>[] items = _items;

        Node<T> newNode = new()
        {
            Data = item,
            Cur = 0//在静态数组中，末尾结点的游标为0，用于区分是否有后继数据元素
        };

        Node<T> node = items[^1];//获取头结点
        Node<T> spareNode = items[spare];//获取备用链表的头结点
        if (node.Cur == 0)//说明这是一个空链表
        {

            items[1] = newNode;
            node.Cur = 1;
            spareNode.Cur = 2;
            _count = ++count;

            return true;
        }

        int i = 1;
        while (i < count + 1)
        {
            node = items[node.Cur];
            if (node.Cur == 0)
            {
                break;//此时node存储的就是最后一个存有数据元素的数组元素
            }

            i++;
        }

        if (i > count)
            return false;

        int spareCur = spareNode.Cur;//用于获取备用链表中第一个空闲的数组元素，该数组元素用于存放新结点
        spareNode.Cur = items[spareCur].Cur;//将原本空闲链表的头结点的游标换成下一个空闲的数组元素

        node.Cur = spareCur;
        items[spareCur].Data = item;
        items[spareCur].Cur = 0;//因为这是默认添加到末尾的，所以游标为0
        _count = ++count;

        return true;
    }

    /// <summary>
    /// 将数据元素添加到链表的开头
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public void AddFirst(T item)
    {
        if (_count >= _items.Length - 2)
            Grow();

        Node<T>[] items = _items;
        int count = _count;
        int spare = _spare;

        int spareCur = items[spare].Cur;//获取备用链表第一个空闲数组的游标
        items[spare].Cur = items[spareCur].Cur;//将备用链表第一个空闲数组的游标替换成下一个

        Node<T> headNode = items[^1];//头结点
        int firstCur = headNode.Cur;//第一个具有实际数据元素的数组元素的游标

        Node<T> newNode = new()
        {
            Data = item,
            Cur = firstCur
        };

        headNode.Cur = spareCur;
        items[spareCur] = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 将数据元素插入到指定的位序中
    /// </summary>
    /// <param name="index">指定的位序</param>
    /// <param name="item">需要插入的数据元素</param>
    /// <exception cref="IndexOutOfRangeException">如果插入的位序超出了数组范围则抛出异常</exception>
    public void Insert(int index, T item)
    {
        if (index < 1 || index > _count)
            throw new IndexOutOfRangeException(nameof(index));

        if (_count > _items.Length - 2)
            Grow();

        Node<T>[] items = _items;
        int count = _count;
        int spare = _spare;

        Node<T> headNode = items[^1];//获取头结点
        int spareCur = items[spare].Cur;//获取备用链表第一个空闲的数组元素的游标
        items[spare].Cur = items[spareCur].Cur;

        int i = 1;
        while (i < index)
        {
            headNode = items[headNode.Cur];
            i++;
        }

        if (i > index)
            return;

        Node<T> newNode = new()
        {
            Data = item,
            Cur = headNode.Cur,
        };
        headNode.Cur = spareCur;
        items[spareCur] = newNode;

        _count = ++count;
    }

    /// <summary>
    /// 当数组容量不够时进行扩容
    /// </summary>
    private void Grow()
    {
        int newCapacity = _items.Length == 0 ? _defaultCapacity : _items.Length * 2;
        if(newCapacity>Array.MaxLength)
            newCapacity = Array.MaxLength;

        Capacity = newCapacity;
    }

    /// <summary>
    /// 删除指定的数据元素
    /// </summary>
    /// <param name="item">需要删除的数据元素</param>
    /// <returns>删除失败返回false，否则返回true</returns>
    /// <exception cref="ArgumentNullException">如果删除的数据元素是空，则抛出异常</exception>
    public bool Remove(T item)
    {
        if(item is null)
            throw new ArgumentNullException(nameof(item));

        int spare = _spare;//备用链表
        int count = _count;//实际元素个数
        Node<T>[] items = _items;

        int i = 1;
        Node<T> node = items[^1];//获取头结点
        while (i < count + 1)
        {
            if (!items[node.Cur].Data?.Equals(item) ?? false)
            {
                node = items[node.Cur];
                i++;
                continue;
            }
            break;
        }

        if (i > count)
            return false;

        int deleteCur = items[node.Cur].Cur;
        items[node.Cur].Cur = items[spare].Cur;
        items[spare].Cur = node.Cur;
        node.Cur = deleteCur;
        _count = --count;

        return true;
    }

    /// <summary>
    /// 删除指定位序处的数据元素
    /// </summary>
    /// <param name="index">需要删除的位序</param>
    /// <returns>删除成功返回true，否则返回false</returns>
    /// <exception cref="IndexOutOfRangeException">如果需要删除的位序不在索引范围之内则抛出异常</exception>
    public bool RemoveAt(int index)
    {
        if (index < 1 || index > _count)
            throw new IndexOutOfRangeException(nameof(index));

        int spare = _spare;
        int count = _count;
        Node<T>[] items = _items;

        int i = 1;
        Node<T> node = items[^1];//获取头结点
        while (items[node.Cur] != null && i < index)
        {
            node = items[node.Cur];
            i++;
        }

        if(i>index ||  node is null)
            return false;

        int deleteCur = items[node.Cur].Cur;
        items[node.Cur].Cur = items[spare].Cur;
        items[spare].Cur = node.Cur;
        node.Cur = deleteCur;
        _count = --count;

        return true;
    }
}

namespace MyStaticLinkedList
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyStaticLinkedList<int> list  = new();
            for (int i = 0; i < 6; i++)
            {
                list.Add(i);
            }
            Console.WriteLine($"利用Add方法添加元素之后，它的长度为：{list.Count}");

            Console.Write("利用索引器获取元素：");
            for (int i = 0; i < list.Count; i++)
                Console.Write($"{list[i],5}");

            list.AddFirst(20);
            list.AddFirst(20);
            list.AddFirst(20);
            Console.Write($"\n利用AddFirst方法添加之后：");
            for(int i = 0;i<list.Count;i++)
                Console.Write($"{list[i],5}");

            list.Insert(2, 15);
            Console.Write($"\n利用Insert方法添加之后：");
            for (int i = 0; i < list.Count; i++)
                Console.Write($"{list[i],5}");

            list.Remove(20);
            list.Remove(20);
            Console.Write("\n使用Remove方法删除元素：");
            for (int i = 0; i < list.Count; i++)
                Console.Write($"{list[i],5}");

            list.RemoveAt(8);
            list.RemoveAt(7);
            Console.Write("\n使用RemoveAt方法删除元素以后：");
            for (int i = 0; i < list.Count; i++)
                Console.Write($"{list[i],5}");

            Console.WriteLine($"\n经过一系列操作之后剩余的元素个数为：{list.Count,5}");
        }
    }
}
```
### <font color = "AA7700">3.6.4静态链表的优缺点</font>
优点：
- 在插入和删除数据元素的时候只需要修改游标，因此改进了在顺序存储结构中进行插入和删除操作需要移动大量数据元素的缺点

缺点：
- 需要额外的空间来存储数据信息
- 链表的长度难以确认
- 失去了顺序存储结构的随机访问特性[[#^fd4866]]

## <font color="886600">3.7 循环链表</font>
- 在单链表中，因为终端结点的指针指向 Null ，所以我们无法通过某一结点访问到整个链表。而在循环链表中，它将终端结点的指针指向头结点从而构成一个循环，像这样头尾相连的链表叫做<font color = "CC6600">「（单向）循环链表」</font>
- 循环链表和单链表的主要差异就在于循环的判断条件上，原理是判断p->next是否为空，而<font color = "CC6600">「现在是判断p->next是否等于头结点」</font>，如果等于头结点则循环结束
- 在单链表中访问第一个结点的时间复杂度是O(1)，而访问终端结点因为需要遍历整个链表因此它的时间复杂度是O(n)。而在循环链表中我们可以用一个<font color = "CC6600">「尾指针」</font>来表示链表，尾指针存储的是终端结点的地址，因此我们访问终端结点的时间复杂度也为O(1)

### <font color = "AA7700">3.7.1实现代码</font>
```C#
public class Node<T>
{
#pragma warning disable CS8618
    public T Data { get; set; }
#pragma warning restore CS8618

    public Node<T>? Next { get; set; }
}

public interface ICircularList<T>
{
    T this[int index] { get; set; }
    void Add(T item);
    void AddFirst(T item);
    void AddLast(T item);
    void Insert(int index, T item);
    bool Remove(T item);
    bool RemoveFirst();
    bool RemoveLast();
    bool RemoveAt(int index);
    void Clear();
    bool IsEmpty();
}

public class CircularList<T> : ICircularList<T>
{
    private readonly Node<T> _headNode;//头结点，指向第一个实际存储数据元素信息的结点
    private readonly Node<T> _rearNode;//尾结点，指向终端结点，终端结点的指针指向头结点

    private int _count;//实际元素个数

    public CircularList()
    {
        _headNode = new()
        {
            Next = null
        };

        _rearNode = new()
        {
            Next = null
        };
    }

    public int Count => _count;

    /// <summary>
    /// 使该类能够实现类似数组循环访问的功能
    /// </summary>
    /// <param name="index">需要访问的索引</param>
    /// <returns>返回数据元素信息</returns>
    /// <exception cref="ArgumentOutOfRangeException">如果索引超出范围则抛出异常</exception>
    /// <exception cref="ArgumentNullException">如果结点为空则抛出异常</exception>
    public T this[int index]
    {
        get
        {
            if(index < 0 || index > _count)
                throw new ArgumentOutOfRangeException(nameof(index),"索引超出范围");
            
            int i = 0;
            Node<T> headNode = _headNode;
            Node<T> node = headNode;
            while (i < index+1 && node.Next != headNode)
            {
                node = node.Next!;
                i++;
            }

            if (i > index+1 || node == headNode)
                throw new ArgumentNullException(nameof(index), nameof(headNode));

            return node.Data;
        }
        set
        {
            if (index < 0 || index > _count)
                throw new ArgumentOutOfRangeException(nameof(index), "索引超出范围");

            int i = 0;
            Node<T> headNode = _headNode;
            Node<T> node = headNode;
            while (i < index+1 && node.Next != headNode)
            {
                node = node.Next!;
                i++;
            }

            if (i > index+1 || node == headNode)
                throw new ArgumentNullException(nameof(index), nameof(headNode));

            headNode.Data = value;
        }
    }

    /// <summary>
    /// 将数据元素添加到链表的末尾
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public void Add(T item)
    {
        Node<T> rearNode = _rearNode;


        if (_headNode.Next is null)
            AddNothing(item);
        else
        {
            Node<T> newNode = new()
            {
                Data = item,
                Next = _headNode
            };
            Node<T>? oldNode = rearNode.Next;
#pragma warning disable CS8602
            oldNode.Next = newNode;
#pragma warning restore CS8602
            rearNode.Next = newNode;
            _count++;
        }

    }

    /// <summary>
    /// 将数据元素添加到第一位
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public void AddFirst(T item)
    {
        int count = _count;
        Node<T> headNode = _headNode;

        if (headNode.Next is null)
        {
            AddNothing(item);
            return;
        }
        Node<T> oldNode = headNode.Next;
        Node<T> newNode = new()
        {
            Data = item,
            Next = oldNode
        };

        headNode.Next = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 将数据元素添加到链表的末尾
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public void AddLast(T item)
    {
        Add(item);
    }

    /// <summary>
    /// 如果需要添加的数据元素是整个链表中的第一个，则调用此方法
    /// </summary>
    /// <param name="item">需要添加的数据元素信息</param>
    private void AddNothing(T item)
    {
        Node<T> headNode = _headNode;
        Node<T> rearNode = _rearNode;
        Node<T> newNode = new()
        {
            Data = item,
            Next = headNode
        };

        (headNode.Next, rearNode.Next) = (newNode, newNode);
        _count++;
    }

    /// <summary>
    /// 将数据元素添加到指定的位序处
    /// </summary>
    /// <param name="index">需要添加的位序</param>
    /// <param name="item">需要添加的数据元素</param>
    /// <exception cref="IndexOutOfRangeException">如果位序超出索引范围则抛出异常</exception>
    /// <exception cref="ArgumentOutOfRangeException">如果链表为空则无法使用该方法，应当抛出异常</exception>
    public void Insert(int index, T item)
    {
        if(index < 0 || index >_count)
            throw new IndexOutOfRangeException(nameof(index));
        if (_count == 0)
            throw new ArgumentOutOfRangeException(nameof(item),"链表为空，无法插入数据元素");

        Node<T> headNode = _headNode;
        int count = _count;

        int i = 1;
        Node<T> node = headNode;
        while (i < index && node!.Next != headNode)
        {
            node = node.Next!;
            i++;
        }

        if (i > index || headNode is null)
            throw new IndexOutOfRangeException(nameof(index));

        Node<T> newNode = new()
        {
            Data = item,
            Next = headNode.Next
        };

        headNode.Next = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 删除指定的数据元素
    /// </summary>
    /// <param name="item">需要删除的数据元素</param>
    /// <returns>删除成功返回true，删除失败返回false</returns>
    /// <exception cref="ArgumentNullException">如果需要删除的数据元素为空则抛出异常</exception>
    public bool Remove(T item)
    {
        if(item is null)
            throw new ArgumentNullException(nameof(item));

        if (_headNode.Next is null)
            return false;

        int count = _count;
        Node<T> rearNode = _rearNode;
        Node<T> headNode = _headNode;
        Node<T> node = headNode;

        int i = 1;
        while (node.Next != headNode && (!node.Next!.Data?.Equals(item) ?? false) && i<count+1)
        {
            node = node.Next;
            i++;
        }

        if (i > count)//说明需要删除的数据元素不存在于链表中
            return false;

        if (node.Next == headNode)//说明需要删除的数据元素是链表中的最后一个
        {
            node.Next = headNode;
            rearNode.Next = node;
            _count = --count;
            return true;
        }

        node.Next = node.Next!.Next;
        _count = --count;
        return true;
    }

    /// <summary>
    /// 删除链表中的第一个数据元素
    /// </summary>
    /// <returns>删除成功返回true，否则返回false</returns>
    public bool RemoveFirst()
    {
        if(_headNode.Next is null)
            return false;

        int count = _count;
        Node<T> headNode = _headNode;

        Node<T> deleteNode = headNode.Next;
        headNode.Next = deleteNode.Next;
        _count = --count;

        return true;
    }

    /// <summary>
    /// 删除链表中的最后一个数据元素
    /// </summary>
    /// <returns>删除成功返回true，否则返回false</returns>
    public bool RemoveLast()
    {
        if (_rearNode.Next is null)
            return false;

        int count = _count;
        Node<T> headNode = _headNode;
        Node<T> rearNode = _rearNode;

        Node<T> deleteNode = headNode;
        while (deleteNode.Next != null && deleteNode.Next.Next != headNode)
        {
            deleteNode = deleteNode.Next;
        }

        deleteNode.Next = headNode;
        rearNode.Next = deleteNode;
        _count = --count;
        return true;
    }

    /// <summary>
    /// 删除指定位序处的数据元素
    /// </summary>
    /// <param name="index">需要删除的数据元素的位序</param>
    /// <returns></returns>
    /// <exception cref="IndexOutOfRangeException">如果位序超出范围则抛出异常</exception>
    public bool RemoveAt(int index)
    {
        if (index < 0 || index > _count)
            throw new IndexOutOfRangeException(nameof(index));

        if (index == 0)
        {
            RemoveFirst();
            return true;
        }

        int count = _count;
        Node<T> headNode = _headNode;

        int i = 1;
        Node<T> node = headNode;
        while (i < index+1 && node!.Next != headNode)
        {
            node = node.Next!;
            i++;
        }

        if (i > index+1 || node == headNode)
            return false;

        Node<T> deleteNode = node.Next!;
        if (deleteNode == headNode)
        {
            RemoveLast();
            return true;
        }

        node.Next = deleteNode.Next;
        _count = --count;
        return true;
    }

    /// <summary>
    /// 将链表清空
    /// </summary>
    public void Clear()
    {
        if (!IsEmpty())
        {
            _headNode.Next = _headNode;
            _rearNode.Next = null;
            _count = 0;
        }
    }

    /// <summary>
    /// 判断链表是否为空
    /// </summary>
    /// <returns></returns>
    public bool IsEmpty()
    {
        if (_headNode.Next == null)
            return true;

        return false;
    }

    /// <summary>
    /// 获取最后一个数据元素
    /// </summary>
    /// <returns>获取成功返回数据元素本身，否则返回默认值</returns>
    public T? GetLastElem()
    {
        Node<T> rearNode = _rearNode;

        if (rearNode.Next is null)
            return default;

        return rearNode.Next.Data;
    }
}

namespace CircularList
{
    internal class Program
    {
        static void Main(string[] args)
        {
            CircularList<int> list = new();

            Console.Write($"利用Add方法添加之后：");
            for (int i = 0; i < 5; i++)
            {
                list.Add(i);
                Console.Write($"{list[i],5}");
            }

            list.AddFirst(21);
            list.AddFirst(32);
            list.AddFirst(12);
            Console.Write($"\n利用AddFirst方法添加之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.AddLast(99);
            list.AddLast(100);
            list.AddLast(101);
            Console.Write($"\n利用AddLast方法添加之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.Insert(11, 221);
            list.Insert(2,222);
            list.Insert(5,225);
            Console.Write($"\n利用Insert方法添加之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.Remove(221);
            list.Remove(101);
            list.Remove(101);
            list.Remove(12);
            Console.Write($"\n利用Remove方法删除之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.RemoveFirst();
            list.RemoveFirst();
            Console.Write($"\n利用RemoveFirst方法删除之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.RemoveLast();
            list.RemoveLast();
            Console.Write($"\n利用RemoveLast方法删除之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.RemoveAt(6);
            list.RemoveAt(0);
            Console.Write($"\n利用RemoveAt方法删除之后：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.Clear();
            Console.Write($"\n利用Clear方法清空链表之后：{list.Count}");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }
        }
    }
}
```

## <font color="886600">3.8 双向循环链表（double linked list）</font>
- 在单链表中，一个结点分别有一个数据域和一个指针域。指针域存储的是下一个结点的地址，但是因为只有一个指针域所以只能找到它的直接后继元素而无法找到它的直接前驱元素。而在双向循环链表中，一个结点有两个指针域，分别存储着该结点的直接前驱元素和直接后继元素，因此我们不仅可以向后访问也可以向前访问
- 双向循环链表是典型的以<font color = "CC6600">「空间换时间」</font>，在单链表中如果想要查找某个结点的直接前驱元素，最坏的结果是O(n)，而如果利用双向循环链表那就是O(1)，但是双向链表因为每个结点都占有两个指针域，所以消耗的空间复杂度也大

### <font color = "AA7700">3.8.1实现代码</font>
```C#
public class Node<T>
{
#pragma warning disable CS8618
    public T Data { get; set; }

    public Node<T> Next { get; set; }

    public Node<T> Prior { get; set; }
#pragma warning restore CS8618
}

public interface IDoubleLinkedList<T>
{
    T this[int index] { get; set; }
    void Add(T item);
    void AddFirst(T item);
    void Insert(int index, T item);
    bool Remove(T item);
    bool RemoveAt(int index);
    bool Clear();
    bool IsEmpty();
}

public class DoubleLinkedList<T> : IDoubleLinkedList<T>
{
    private readonly Node<T> _headNode = new();
    private int _count;

    public int Count => _count;

    public DoubleLinkedList()
    {
        _headNode.Next = _headNode;
        _headNode.Prior = _headNode;

        _count = 0;
    }
    public T this[int index]
    {
        get
        {
            if (index < 0 || index > _count)
                throw new IndexOutOfRangeException(nameof(index));

            int i = 0;
            Node<T> headNode = _headNode;
            Node<T> node = headNode;
            while (node.Next != headNode && i < index + 1)
            {
                node = node.Next;
                i++;
            }

            if (i > index + 1 || node == headNode)
                return default!;

            return node.Data;
        }
        set
        {
            if(value is null) 
                throw new ArgumentNullException(nameof(value));

            if (index < 0 || index > _count)
                throw new IndexOutOfRangeException(nameof(index));

            int i = 0;
            Node<T> headNode = _headNode;
            Node<T> node = headNode;
            while (node.Next != headNode && i < index + 1)
            {
                node = node.Next;
                i++;
            }

            if (i > index + 1 || node.Next == headNode)
                throw new ArgumentOutOfRangeException(nameof(index), "无法查找到需要修改的数据元素");

            node.Data = value;
        }
    }

    /// <summary>
    /// 默认将数据元素添加到链表的末尾
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    public void Add(T item)
    {
        int count = _count;
        Node<T> headNode = _headNode;

        Node<T> lastNode = headNode.Prior;
        Node<T> newNode = new()
        {
            Data = item,
            Next = headNode,
            Prior = lastNode
        };

        lastNode.Next = newNode;
        headNode.Prior = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 将数据元素添加到链表的第一位
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    /// <exception cref="ArgumentNullException">如果添加的数据元素为空则抛出异常</exception>
    public void AddFirst(T item)
    {
        if (item is null)
            throw new ArgumentNullException(nameof(item));

        int count = _count;
        Node<T> headNode = _headNode;
        Node<T> nextNode = headNode.Next;

        Node<T> newNode = new()
        {
            Data = item,
            Next = nextNode,
            Prior = headNode
        };

        nextNode.Prior = newNode;
        headNode.Next = newNode;
        _count = ++count;
    }
    
    /// <summary>
    /// 将数据元素插入到指定的位序处
    /// </summary>
    /// <param name="index">需要插入的指定位序</param>
    /// <param name="item">需要插入的数据元素</param>
    /// <exception cref="ArgumentOutOfRangeException">如果位序超出索引范围或者需要插入的数据元素为空则抛出异常</exception>
    public void Insert(int index, T item)
    {
        if (index < 0 || index >= _count || item is null)
            throw new ArgumentOutOfRangeException(nameof(index), nameof(item),"插入的索引超出范围或者插入的数据元素为空");

        if (IsEmpty())
        {
            Add(item);
            return;
        }

        int i = 1;
        int count = _count;
        Node<T> headNode = _headNode;
        Node<T> node = headNode;

        while (i < index + 1 && node.Next != headNode)
        {
            node = node.Next;
            i++;
        }

        Node<T> newNode = new()
        {
            Data = item,
            Next = node.Next,
            Prior = node
        };

        node.Next = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 删除指定的数据元素
    /// </summary>
    /// <param name="item">需要删除的数据元素</param>
    /// <returns></returns>
    /// <exception cref="ArgumentNullException">如果需要删除的数据元素为空则抛出异常</exception>
    public bool Remove(T item)
    {
        if (item is null)
            return false;

        int i = 1;
        int count = _count;
        Node<T> headNode = _headNode;
        Node<T> node = headNode;

        while (i < count + 1 && node.Next != headNode)
        {
            node = node.Next;
            if (node.Data!.Equals(item))
                break;

            i++;
        }

        if (i > count + 1 || node == headNode)
            return false;

        Node<T> beforeNode = node.Prior;
        Node<T> afterNode = node.Next;

        beforeNode.Next = afterNode;
        afterNode.Prior = beforeNode;
        _count = --count;
        return true;
    }

    public bool RemoveAt(int index)
    {
        if (index < 0 || index > _count)
            return false;

        int i = 0;
        int count = _count;
        Node<T> headNode = _headNode;
        Node<T> node = headNode.Next;

        while (i < index && node != headNode)
        {
            node = node.Next;
            i++;
        }

        if (i > index+0 || node == headNode)
            return false;

        Node<T> beforeNode = node.Prior;
        Node<T> afterNode = node.Next;

        beforeNode.Next = afterNode;
        afterNode.Prior = beforeNode;
        _count = --count;
        return true;
    }

    public bool Clear()
    {
        if (IsEmpty())
            return false;

        (_headNode.Next, _headNode.Prior) = (_headNode, _headNode);
        return true;
    }

    /// <summary>
    /// 判断链表是否为空
    /// </summary>
    /// <returns>空则返回true，否则返回false</returns>
    public bool IsEmpty()
    {
        if (_headNode.Next == _headNode)
            return true;
        return false;
    }
}

namespace MyDoubleLinkedList
{
    internal class Program
    {
        static void Main(string[] args)
        {

            DoubleLinkedList<int> list = new();

            Console.WriteLine($"链表是否为空：{list.IsEmpty()}");

            Console.Write($"利用Add方法添加数据元素：");
            for (int i = 1; i <= 5; i++)
            {
                list.Add(i);
            }
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.AddFirst(10);
            list.AddFirst(11);
            list.AddFirst(12);
            Console.Write($"\n利用AddFirst方法添加数据元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.Insert(0, 120);
            list.Insert(5, 125);
            list.Insert(9, 1210);
            Console.Write($"\n利用Insert方法添加数据元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.Remove(1210);
            list.Remove(120);
            list.Remove(125);
            list.Remove(00000);
            Console.Write($"\n利用Remove方法移除数据元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            list.RemoveAt(0);
            list.RemoveAt(0);
            list.RemoveAt(0);
            list.RemoveAt(0);
            list.RemoveAt(2);
            Console.Write($"\n利用RemoveAt方法移除数据元素：");
            for (int i = 0; i < list.Count; i++)
            {
                Console.Write($"{list[i],5}");
            }

            Console.WriteLine($"\n将链表清空：{list.Clear()}");
            Console.WriteLine($"链表是否为空：{list.IsEmpty()}");
        }
    }
}
```
## <font color="886600">3.9 思维导图（double linked list）</font>
![第三章 线性表 思维导图.png](https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101557569.png)
