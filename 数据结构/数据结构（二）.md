---
title: 数据结构（二）
date: 2023-11-02 16:35:12
top_image: https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101556773.png
cover: https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101556773.png
categories: 
- [数据结构]
- [文章]
tags:
- [概念]
- [时间复杂度]
- [空间复杂度]
- [事后统计方法]
- [事前分析估计方法]
---

# 第二章 算法
## <font color="886600">2.1 算法的定义</font>
<strong>定义：算法是对解决问题步骤的描述，通常以有限序列的指令表示，每条指令在计算机中可以完成一个或多个操作</strong>
## <font color="886600">2.2 算法的特性</font>
- 输入：算法可以有0个或多个输入
- 输出：算法至少要有一个输出，否则没有意义
- 有穷性：算法在执行有限的步骤后能够自动结束，并且每一步都在可接受的时间范围之内
- 确定性：算法的每一个步骤都必须有明确的含义，不会出现二义性
- 可行性：算法的每一步都必须在执行有限次后完成
## <font color="886600">2.3 算法的设计要求</font>
- 正确性：能够正确描述问题的需求并得到正确的答案，对于输入、输出和加工处理无歧义性，算法的正确性具有以下四个层次
	- 算法程序没有语法错误
	- 算法程序对于合法的输入能够得到期待的答案
	- 算法程序对于错误的输入能够输出合理的说明
	- 算法程序对于精心挑选的，甚至刁难的测试数据都有满足的结果
- 可读性：算法在设计的过程中要注意便于阅读、理解和交流
- 健壮性：算法程序在针对错误的输入时能够做出合理的处理而不是弹出异常终止运行
- 时间上高效率
- 空间上低存储量
## <font color="886600">2.4 算法效率的度量方法</font>
一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于以下四个因素：
1. 算法采用的策略和方法
2. 编译时产生的代码质量
3. 问题的输入规模
4. 机器执行指令的速度

其中第一条是算法好坏的根本，第二条和第四条取决于采用的编译软件和计算机硬件，因此我们可以发现<font color="CC6600">「一个程序运行的时间，主要依赖于算法所采用的策略、方法以及问题输入的规模」</font>
### <font color="AA7700">2.4.1 事后统计方法</font>
<strong>定义：这种方法主要是通过编写算法的核心代码以及测试用例，最后通过计算机实际运行从而确定其算法效率的高低</strong>

缺陷：
-  必须依据算法事前编制好程序，这通常需要大量的时间和精力
- 时间的比较过于依赖硬件和软件
- 算法的测试数据难以设计
### <font color="AA7700">2.4.2 事前分析估算方法</font>
<font color = "CC6600"><strong>定义：在计算机程序编制前，通过统计方法进行估算。</font></strong>

事前分析估算法无需像事后统计法那样编写出实现代码和测试数据，因此我们只需分析算法的核心操作步骤、循环次数、递归深度等，然后用数学推导来估算算法的时间复杂度。

以下是几个例子用于理解事前分析估算法
第一种算法：
```C
int i,sum=0,n=100;  //执行1次;
for(i=1;i<=n;i++)  //执行n+1次；
{
	sum = sum+1;  //执行n次;
}
print("%d",sum);  //执行1次；
```
因此这个算法一共执行了：1+n+1+n+1=2n+3次

第二种算法：
```c
int i,sum=0,n=100; //执行了1次
sum = n*(1+100)/2;  //执行了1次
print("%d",sum);  //执行了1次
```
所以这个算法一共执行了：1+1+1次

第三种算法：
```c
int i,j,x=0,sum=0,n=100;  //执行了1次
for(i=1;i<=n;i++)  /*i=1只在初始化时执行1次，i<=n每次判断都要执行一次因此是n+1次，i++执行n此，所以一共执行2n+2次*/
{
	for(j=1;j<=n;j++) /*j=1在每次外循环执行时都要执行1次，所以是n次，j<=n要执行n+1次但是有外循环所以是n(n+1)次，j++执行n次同样因为有外循环所以执行n²次，所以一共执行2n²+2n次*/
	{
		x++;  //内循环执行n次，外循环n次，因此n²次
		sum=sum+x; //同上
	}
}
print("%d",sum);//执行1次；
```
所以这个算法一共执行：1+2n+2+2n²+2n+n²+n²+1=4n²+4n+4次
## <font color="886600">2.5 算法的时间复杂度</font>
<strong>定义：T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度也就是算法的时间量度，记作T(n)=O(f(n))</strong>
理解：T(n)就是上述三个算法示例的总执行次数，也就是说算法的总执行次数就是它的时间复杂度（但是在推导大O阶法中我们一般只保留最高项并且去除最高项的系数），所以T(n)增长越慢的算法越是优秀

### <font color="AA7700">2.5.1 推导大O阶方法</font>
- 用常数1取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高项
- 如果最高项存在且系数不为1，则将系数改为1

所以在上述三个示例中，它们的时间复杂度分别为：O(n)，O(1)，O($n^2$)

常见的大O阶有
- 常数阶：O(1)
- 线性阶：O(n)
- 平方阶：O(n²)
- 立方阶：O(n³)
- 对数阶：O(logn)
- nlogn阶：O(nlogn)
- 指数阶：O($2^n$)

时间复杂度分为：最坏时间复杂度和平均时间复杂度，其中平均时间复杂度最有意义，因为这是我们最期待的运行时间，但是这需要通过运行一定数量的实验数据才能估算出来，所以在通常情况下我们说得时间复杂度是指最坏时间复杂度。

下面是整一章节的思维导图
![第二章 算法.png](https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309101556773.png)
