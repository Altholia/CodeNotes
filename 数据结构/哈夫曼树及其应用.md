---
title: 哈夫曼树及其应用
date: 2023-12-16 12:31:54
description: 哈夫曼树是构建最优二叉树的方法，以最小化带权路径长度。哈夫曼编码是哈夫曼树的一种应用方式，它通过字符频率创建树结构，哈夫曼编码赋予频率高的字符更短的编码，低频字符则获得较长编码，形成一种高效的前缀编码系统，实现数据的有效压缩。这种方法在数据传输和存储中广泛应用，因其压缩效率而受到重视。
categories: 
- [数据结构,树]
tags: 
- 哈夫曼树
- C#
top_image: https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312181701317.jpg
cover: https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312181701317.jpg
keywords: 
- 哈夫曼树
- 哈夫曼编码
- 路径
- WPL
---
# 哈夫曼树
## <font color = "886600">定义</font>
要想理解什么是<font color = "CC6600">「哈夫曼树」</font>需要先理解一些概念，为了能够更好的理解这些概念，我们需要辅以图片的形式来帮助我们理解：
![哈夫曼.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312180921238.png)
- 路径：路径即为两结点之间的所连接的分支
- 结点的路径长度：路径长度即为两结点之间的分支数量，例如根结点到C结点的路径长度为3
- 树的路径长度：树的路径长度即为<font color = "BA8448">【根结点到每个结点的路径长度之和】</font>
- 权值：如上图所示，A结点的权值即为5%
- 结点的带权路径的长度：结点的带权路径的长度即为<font color = "BA8448">【结点的权值×结点的路径长度】</font>，例如D结点的带权路径长度为：30×4=60
- 树的带权路径长度（Weighted Path Length,WPL）：即所有<font color = "BA8448">【结点的带权路径的长度之和】</font>
- <font color = "BA8448">哈夫曼树：WPL值最小的树被称为最优二叉树，亦被称为哈夫曼树</font>

## <font color = "886600">哈夫曼树的构造</font>
参考下表：

| A | B | C | D | E |
|:-:|:-:|:-:|:-:|:-:|
| 5%|15%|40%|30%|10%|
构造哈夫曼树的步骤：
1. 将各个叶结点按权值从小到大进行排列，组成一个有序序列：A5,E10,B15,D30,C40
2. 取最前面两个结点（即权值最小的两个结点）组成新结点N<sub>1</sub>的孩子，其中权值较小的结点在左边。新结点的权值为两个孩子的权值之和
	- ![N1结点.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312180956316.png)
3. 将新结点（N<sub>1</sub>）替换序列中的A5和E10：N<sub>1</sub>15,B15,D30,C40
4. 重复（2，3）步即可
5. ![哈夫曼树.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312181047239.png)
因此上图中的WPL=40+60+2×30+2×30+3×15+3×15+4×5+4×10=205。并且我们可以发现，权值越大的结点离根结点也越近

# 哈夫曼编码
<strong>一般地，设需要编码的字符集为{d<sub>1</sub>,d<sub>2</sub>,……,d<sub>n</sub>}，各个字符在电文中出现的次数或频率集合为{w<sub>1</sub>,w<sub>2</sub>,……,w<sub>n</sub>}，以d<sub>1</sub>,d<sub>2</sub>,……,d<sub>n</sub>作为叶结点，以w<sub>1</sub>,w<sub>2</sub>,……,w<sub>n</sub>作为相应叶结点的权值来构造一棵哈夫曼树。规定哈夫曼树的左分支为0，右分支为1，则从根结点到叶结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。哈夫曼编码是哈夫曼树的一种应用形式，利用哈夫曼树我们可以得到平均长度最短的编码</strong>

哈夫曼编码是一种用于数据压缩的聪明方法，该编码方式是将出现频率不那么高的元素用更长的代码表示，而出现频率较高的元素用更短的代码表示，这就好像我们现在发短信一样用kknd来表示“看看你的”，这样能有效的节省时间和空间。

下面请看一个例子：假设我们有一个字符串："AAAABBC"，在这个字符串中，'a'出现了4次，'b'出现了2次，'c'出现了1次。如果我们使用ASCII编码方式对其进行编码，则其代码为：001_001_001_001_010_010_011，但是使用哈夫曼编码则可以将出现频率高的字母给予较短的编码，频率出现较低的字母给予较长的编码，这样可以使编码的平均长度变短，请看下图：
![编码.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312181649317.png)
通过哈夫曼树的构造方法构造出一棵哈夫曼树之后，将左子树的权重全部变为0，右子树的权重全部变为1，如下图所示：
![编码.png](https://arturia-blog-1316646580.cos.ap-shanghai.myqcloud.com/ArturiaBlogPicGo/202312181651251.png)
则重新编码之后的代码为：1_1_1_1_01_01_00，相比之前的代码确实是短了许多，<font color = "BA8448">【经过观察可以发现，上述的编码中任意字符的编码都不会是其他字符的编码的前缀，这种编码称作前缀编码】</font>