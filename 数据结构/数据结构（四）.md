---
title: 数据结构（四）
date: 2023-11-03 17:55:25
top_image: https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309161225088.png
cover: https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309161225088.png
keywords: 
- [队列]
- [栈]
- [递归]
- [斐波那契数列]
tags:
- [队列]
- [栈]
categories: 
- [数据结构]
- [文章]
---

# 4 栈与队列
## <font color = "886600">4.1 栈</font>
<strong>定义：栈是一种仅限定在表尾（栈顶）中进行插入和删除的线性表</strong>
- 我们将插入和删除的那一端称为<font color = "CC6600">「栈顶（top）」</font>,另一端称为<font color = "CC6600">「栈底（bottom）」</font>
- 不含任何数据元素栈称为<font color = "CC6600">「空栈」</font>
- 栈遵循<font color = "CC6600">「LIFO原则^[LIFO（Last-In，First-Out）：它的意思是“后进先出”。它是一种根据时间顺序来管理数据的原则，根据LIFO原则，最后添加的数据元素最先被删除，而最早添加的数据元素将被最后移除]」</font>
- 栈是一种特殊的线性表，这意味着它具有线性关系，即前驱后继关系
- 栈的插入操作被称为：<font color = "CC6600">「入栈」「压栈」「进栈」</font>
- 栈的删除操作被称为：<font color = "CC6600">「弹栈」「出栈」</font>

### <font color = "AA7700">4.1.2 栈的抽象数据类型</font>
```C#
ADT 栈（Stack）
Data
	同线性表相同。具有相同数据类型的数据元素，相邻的元素具有前驱和后继关系
Operation
	InitStack()：初始化操作，建立一个空栈
	InitStack(int capacity)：初始化操作，建立一个指定容量的栈
	Push(T item)：进栈操作，将数据元素添加进栈中
	Pop()：出栈操作，获取栈顶的数据元素并删除
	Peek()：获取栈顶的数据元素但不删除
	IsEmpty()：判断是否为空栈，如果是则返回true，如果不是则返回false
	ClearStack()：将栈中的数据元素全部清空
	DestroyStack()：若栈存在，则销毁它
EndADT
```

### <font color = "AA7700">4.1.3 栈的顺序存储结构</font>
<strong>概念：栈的顺序存储结构其实就是线性表的顺序结构的简化版，我们称为「顺序栈」</strong>
- 顺序栈也是用数组来实现
- 我们将数组的<font color = "CC6600">「0端」</font>看作栈底
- 使用<font color = "CC6600">「top变量」</font>来定位栈顶元素在数组的位置
- 判断空栈的判定条件是：top = -1;
- 栈的进栈和出栈不包含循环体，所以时间复杂度均为O(1)

#### <font color = "DDAA00">4.1.3.1 两栈共享空间</font>
<strong>概念：所谓的两栈共享空间其实就是两个「数据类型」相同的栈共享一个数组作为存储空间，它们从数组的两端向中间生长</strong>
- 假设数组长度为：StackSize
	- 当栈1为空时：top = -1
	- 当栈2为空时：top = StackSize
	- 当栈1满，栈2空时：top<sub>1</sub> = StackSize-1，top<sub>2</sub> = StackSize
	- 当栈2满，栈1空时：top<sub>1</sub> = -1，top<sub>2</sub> = 0
	- 当两栈见面时：top<sub>1</sub> + 1 = top<sub>2</sub>
- 两栈共享空间这种数据结构，通常是两栈空间容量的需求相反时才会使用，即：一栈进栈，另一栈出栈。否则两栈同时增长很容易溢出
- 注意：使用两栈共享空间这种数据结构的一个大前提是两栈的数据类型要相同

#### <font color = "DDAA00">4.1.3.2 顺序栈的实现代码</font>
```C#
public interface IMyStack<T>
{
    void Push(T item);
    void Grow(int size);
    T Pop();
    T Peek();
    bool IsEmpty();
    bool ClearStack();
    bool DestroyStack();
}

public class MyStack<T> : IMyStack<T>
{
    private T[] _items;
    private int _top;

    private const int _defaultCapacity = 4;
    public MyStack()
    {
        _items = Array.Empty<T>();
        _top = -1;
    }

    public MyStack(int capacity)
    {
        _items = new T[capacity];
        _top = -1;
    }

    //获取栈中的实际元素个数
    public int Count => _top + 1;
    /// <summary>
    /// 修改或获取栈的存储容量
    /// </summary>
    public int Capacity
    {
        get=>_items.Length;
        set
        {
            if (value < 0 || value < _top)
                throw new ArgumentOutOfRangeException(nameof(value));

            if (value != _items.Length)
            {
                T[] newItems = new T[value];
                if (_top != -1)
                {
                    int top = _top;
                    T[] items = _items;

                    for (int i = 0; i <= top; i++)
                    {
                        newItems[i] = items[i];
                    }

                    _items = newItems;
                }
                else
                {
                    _items = newItems;
                }
            }
        }
    }

    /// <summary>
    /// 将数据元素进行入栈操作
    /// </summary>
    /// <param name="item">需要入栈的数据元素</param>
    public void Push(T item)
    {
        int top = _top;
        T[] items = _items;

        if ((uint)top < (uint)items.Length-1)
        {
            items[++top] = item;
            _top = top;
        }
        else
        {
            Grow(items.Length+1);
            _items[++top] = item;
            _top = top;
        }
    }

    /// <summary>
    /// 对栈的存储容量进行扩容，并将需要入栈的数据元素进行入栈操作
    /// </summary>
    /// <param name="size">扩容</param>
    public void Grow(int size)
    {
        int capacity = _items.Length == 0 ? _defaultCapacity : _items.Length * 2;

        if (capacity > Array.MaxLength)
            capacity = Array.MaxLength;
        if (capacity < size)
            capacity = size;

        Capacity = capacity;
    }

    /// <summary>
    /// 对栈顶的数据元素进行出栈操作
    /// </summary>
    /// <returns>返回出栈的数据元素</returns>
    /// <exception cref="ArgumentNullException">如果为空栈，则抛出异常</exception>
    public T Pop()
    {
        if (IsEmpty())
            throw new ArgumentNullException(nameof(_items));

        int top = _top;
        T[] items = _items;

        T item = items[top];

        items[top] = default!;
        _top = --top;

        return item;
    }

    /// <summary>
    /// 获取栈顶的数据元素，但是并不删除
    /// </summary>
    /// <returns>返回栈顶数据元素</returns>
    /// <exception cref="ArgumentNullException">如果为空栈，则抛出异常</exception>
    public T Peek()
    {
        if(IsEmpty())
            throw new ArgumentNullException(nameof(_items));

        return _items[_top];
    }

    /// <summary>
    /// 检查是否为空栈
    /// </summary>
    /// <returns>如果是空栈则返回true，否则返回false</returns>
    public bool IsEmpty()
    {
        if(_top == -1)
            return true;
        return false;
    }

    /// <summary>
    /// 将栈中的数据元素清空
    /// </summary>
    /// <returns>返回true</returns>
    public bool ClearStack()
    {
        Array.Clear(_items, 0, _top);
        _top = -1;
        return true;
    }

    /// <summary>
    /// 将栈销毁
    /// </summary>
    /// <returns>销毁成功返回true</returns>
    public bool DestroyStack()
    {
        ClearStack();
        _items = null!;

        return true;
    }
}

namespace MyStack
{
    internal class Program
    {
        static void Main(string[] args)
        {
            MyStack<int> stack = new();
            MyStack<int> stack2 = new(8);

            Console.Write("栈顶元素为：");
            for (int i = 1; i <= 5; i++)
            {
                stack.Push(i);
            }
            Console.Write($"{stack.Peek()}");

            Console.Write("\n删除栈顶元素后的栈顶元素为：");
            stack.Pop();
            stack.Pop();
            stack.Pop();
            stack.Pop();
            Console.Write($"{stack.Peek()}");

            for (int i = 1; i <= 5; i++)
            {
                stack.Push(i);
            }

            Console.Write("\n清空栈：");
            Console.Write($"{stack.ClearStack()}，现在的数据元素个数为：{stack.Count}");
        }
    }
}
```

### <font color = "AA7700">4.1.4 栈的链式存储结构</font>
<strong>定义：栈的链式存储结构被简称为「链栈」</strong>
- 我们通常将栈顶放在线性表的头部
- 所以我们将头指针和栈顶指针合并
- 链栈为空时，top = Null
- 和顺序栈的时间复杂度一样，出栈和进栈的时间复杂度都是O(1)
- 链栈和顺序栈同线性表的顺序表和链表一样，如果你的元素个数变化较大则使用链栈，否则使用顺序栈。
#### <font color = "DDAA00">4.1.4.1 链栈的实现代码</font>
```C#
internal class Node<T>
{
    public T? Data { get; set; }
    public Node<T>? Next { get; set; }
}

public interface IMyLinkedStack<T>
{
    void Push(T item);
    T? Pop();
    T? Peek();
    bool IsEmpty();
    bool ClearStack();
}

public class MyLinkedStack<T> : IMyLinkedStack<T>,IDisposable
{
    private Node<T>? _headNode;
    private int _count;

    public int Count => _count;

    public MyLinkedStack()
    {
        _headNode = new();
        _count = 0;

    }

    /// <summary>
    /// 进栈操作
    /// </summary>
    /// <param name="item">需要进栈的数据元素</param>
    public void Push(T item)
    {
        int count = _count;
        Node<T> headNode = _headNode!;

        Node<T> newNode = new()
        {
            Data = item,
            Next = headNode.Next ?? null
        };

        headNode.Next = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 出栈操作
    /// </summary>
    /// <returns>将出栈的数据元素信息返回，如果为空栈则返回默认值</returns>
    public T? Pop()
    {
        int count = _count;
        Node<T> headNode = _headNode!;
        if (IsEmpty())
            return default;

        Node<T> deleteNode = headNode.Next!;
        headNode.Next = deleteNode.Next;

        _count = --count;
        return deleteNode.Data;
    }

    /// <summary>
    /// 类似出栈操作，但是并不会删除栈顶数据元素，而只是获取数据元素的信息
    /// </summary>
    /// <returns>获取成功返回数据元素，获取失败返回默认值</returns>
    public T? Peek()
    {
        Node<T> headNode = _headNode!;
        if (IsEmpty())
            return default;

        return headNode.Next!.Data;
    }

    /// <summary>
    /// 判断链栈是否为空
    /// </summary>
    /// <returns>为空返回true，否则返回false</returns>
    public bool IsEmpty()
    {
        Node<T> headNode = _headNode!;
        if (headNode.Next is null)
            return true;
        return false;
    }

    /// <summary>
    /// 清空链表
    /// </summary>
    /// <returns>清空成功返回true</returns>
    public bool ClearStack()
    {
        Node<T> headNode = _headNode!;

        headNode.Next = null;
        _count = 0;

        return true;
    }

    /// <summary>
    /// 销毁链栈
    /// </summary>
    /// <returns>销毁成功返回true</returns>
    public void Dispose()
    {
        ClearStack();
        GC.SuppressFinalize(this);
    }
}

namespace MyLinkedStack
{
    internal class Program
    {
        static void Main(string[] args)
        {

            using MyLinkedStack<int> stack = new();

            for (int i = 1; i <= 5; i++)
            {
                stack.Push(i);
            }
            Console.WriteLine("使用Push进行进栈操作之后，它的数据元素个数为：" + stack.Count);

            Console.Write($"栈顶数据元素为：{stack.Peek()}");

            stack.Pop();
            Console.WriteLine($"\n删除栈顶元素之后：{stack.Peek()},数据元素个数为：{stack.Count}");

            Console.WriteLine($"将链栈清空：{stack.ClearStack()}，则它的数据元素个数为：{stack.Count}；");
        }
    }
}

```

### <font color = "AA7700">4.1.5 栈的应用</font>
<strong>概念：栈的引入简化了程序设计的问题，它将问题划分为不同的关注层次，使得思考范围缩小，可以让我们更加聚焦在核心问题</strong>

#### <font color = "DDAA00">4.1.5.1 递归</font>
<strong>概念：在编程领域中，自己调用自己的函数叫做递归函数</strong>
- 递归函数必须有一个结束条件
- 递归函数不能递归太深，否则容易造成栈溢出并且产生大量的函数副本，这将耗费大量的时间和内存

1. 斐波那契数列
	- <strong>概念：斐波那契数列是一个经典的数学数列</strong>
		- 它的第一个数字和第二个数字都是1
		- 从第三个数字开始，它的形成是前两个数字之和

1.1. 使用迭代方法实现斐波那契数列
```C#
static void Main(string[] args)
{
    Fib(40);
}

static void Fib(int num)
{
    int[] sum = new int[num];
    sum[0] = 1;
    sum[1] = 1;

    Console.Write($"{sum[0],5},{sum[1],5}");
    for (int i = 2; i < num; i++)
    {
        sum[i] = sum[i - 1] + sum[i - 2];
        Console.Write($"{sum[i],5}");
    }
}
```
1.2 使用递归实现斐波那契数列
```C#
namespace ConsoleApp1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            for (int i = 1; i <= 40; i++)
                Console.Write($"{Fib(i),5}");
        }

        static int Fib(int i)
        {
            if (i < 2)
              return  i == 0 ? 0 : 1;
            return Fib(i - 1) + Fib(i - 2);
        }
    }
}
```
#### <font color = "DDAA00">4.1.5.2 四则运算表达式求值</font>
 <strong>在我们对四则运算进行求值的时候遇到的最大困难就是运算符号的优先级以及括号的嵌套，那么为了应对这种情况于是出现了一种没有括号的表达式，即“逆波兰”表达式，也叫做“后缀表达式”</strong>
 - 后缀表达式的形成：所谓的后缀表达式就是将中缀表达式（正常的四则运算表达式）的所有符号往后放，方法就是“在循环的过程中，如果发现是数字则输出到目标集合，如果是符号则判断优先级，如果优先级高于栈顶元素则入栈，否则栈顶元素出栈输出^[注意，当栈顶元素出栈之后又会出现一个新的栈顶元素，那么这个栈顶元素依然需要和入栈的元素比较优先级，如果栈顶元素的优先级高于入栈元素那么依然需要将栈顶元素弹出，直到栈顶元素比入栈元素的优先级低]。由于后缀表达式是无括号表达式，因此括号不能输出到目标集合，另外，如果即将入栈的元素是“)”，则需要将“(”以上的元素全部出栈，然后“(”“)”删除不输出到目标集合
 - 后缀表示的计算方法：与“后缀表达式的形成”不同，“后缀表达式的形成”是将符号入栈，而它的计算则是将数字入栈。方法就是“如果在循环的过程中发现是数字则入栈，如果是符号则将栈顶元素（0）与它的下一个元素（1）进行计算,这里需要注意的是，是用1去计算0，比如是减法运算，则是1-0，如果是除法则是1/0

实现代码：
```C#
using System.Linq.Expressions;
using System.Text.RegularExpressions;

namespace MyLinkedStack
{
    internal class Program
    {
        private static readonly Dictionary<string, int> _operatorPriority = new()
        {
            { "+", 1 },
            { "-", 1 },
            { "*", 2 },
            { "/", 2 },
            { "(", 10 },
            { ")", 10 },
        };
        static void Main(string[] args)
        {
            using MyLinkedStack<int> stack = new();

            Console.Write("请输入一段四则运算：");
            try
            {
                string tokens = Console.ReadLine()!;
                List<string> tokenList = TransformList(tokens);

                tokenList = TransformSuffix(tokenList);
                Console.WriteLine(Calculate(tokenList));
            }
            catch (ArgumentNullException ex)
            {
                Console.WriteLine($"您输入的表达式为空：{ex.Message}");
            }
        }

        /// <summary> 将字符串根据运算符号进行切割
        /// </summary>
        /// <param name="expression">需要切割的字符串</param>
        /// <returns>返回集合</returns>
        static List<string> TransformList(string expression)
        {
            string pattern = @"(\d+(\.\d*)?)|([+\-*/()])";
            MatchCollection matches = Regex.Matches(expression, pattern);

            List<string> tokens = new();
            foreach (Match match in matches.Cast<Match>())
            {
                tokens.Add(match.Value);
            }

            return tokens;
        }

        /// <summary> 将中缀表达式转换成后缀表达式
        /// </summary>
        /// <param name="tokens">需要转换成后缀表达式的中缀表达式</param>
        /// <returns></returns>
        static List<string> TransformSuffix(List<string> tokens)
        {
            List<string> newTokens = new();
            MyLinkedStack<string> stack = new();

            foreach (string token in tokens)
            {
                //如果token是数字，则添加到集合中
                if (double.TryParse(token, out _))
                {
                    newTokens.Add(token);
                    continue;
                }

                //如果token是“）”则说明其中一个括号结束，则将括号内的所有运算符添加到集合，并将“（”删除
                if (token == ")")
                {
                    while (stack.Peek()! != "(")
                    {
                        newTokens.Add(stack.Pop()!);
                    }

                    stack.Pop();
                }
                else
                {
                    //如果token是“（”则直接入栈 或者 如果token运算符的优先级高于栈顶元素则也入栈
                    if ((token == "(" || EstimateSuffix(token, stack.Peek())) && stack.Peek() != "(")
                    {
                        stack.Push(token);
                        continue;
                    }

                    //如果token的优先级低于栈顶元素，则将栈顶元素弹出并加入集合,然后将token入栈
                    if (!EstimateSuffix(token, stack.Peek()))
                    {
                        if (stack.Peek() == "(")
                        {
                            stack.Push(token);
                            continue;
                        }

                        do
                        {
                            newTokens.Add(stack.Pop()!);
                        } while (!EstimateSuffix(token, stack.Peek()) && stack.Peek() != "(");

                        stack.Push(token);
                    }
                }
            }

            while(stack.Count > 0)
                newTokens.Add(stack.Pop()!);

            return newTokens;
        }

        /// <summary> 对后缀表达式进行计算
        /// </summary>
        /// <param name="tokens">需要进行计算的后缀表达式</param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException">如果token为空或者数据元素为空则抛出异常</exception>
        static double Calculate(List<string>? tokens)
        {
            if (tokens is null || tokens.Count == 0)
                throw new ArgumentNullException(nameof(tokens));

            MyLinkedStack<double> stack = new();
            foreach (string token in tokens)
            {
                if(double.TryParse(token,out double result))
                    stack.Push(result);
                else
                {
                    double countOne, countTwo;
                    switch (token)
                    {
                        case "+":
                            stack.Push(stack.Pop() + stack.Pop());
                            break;
                        case "-":
                            countOne = stack.Pop();
                            countTwo = stack.Pop();
                            stack.Push(countTwo - countOne);
                            break;
                        case "*":
                            stack.Push(stack.Pop() * stack.Pop());
                            break;
                        case "/":
                            countOne = stack.Pop();
                            countTwo = stack.Pop();
                            stack.Push(countTwo / countOne);
                            break;
                    }
                }
            }

            return stack.Pop();
        }

        /// <summary> 用于判断运算符号的优先级
        /// </summary>
        /// <param name="symbolOne"></param>
        /// <param name="symbolTwo"></param>
        /// <returns></returns>
        static bool EstimateSuffix(string? symbolOne,string? symbolTwo)
        {
            if (symbolTwo is null || symbolOne is null)
                return true;

            _operatorPriority.TryGetValue(symbolOne, out int one);
            _operatorPriority.TryGetValue(symbolTwo, out int two);
            return one > two;
        }
    }
}

```
这里说几个点以提醒未来的自己不要犯同样的错误：
- 在进行后缀表达式计算时，计算出的任何结果都要入栈，就是结果是0也要入栈，否则会影响后面的计算
- 因为C#输入的表达式是一串string，因此需要将它按运算符进行切割，这里放一个正则表达式“@"(\\d+(\\.\d*)?)|([+\\-\*/()])"”

## <font color = "886600">4.2 队列（Queue）</font>
<strong>定义：队列是一种只允许一端插入另一端删除的线性表</strong>
- 队列是一种<font color = "CC6600">「先进先出（First-In，First-Out）」</font>的线性表
- 允许删除的一端被称为<font color = "CC6600">「队头」</font>，允许插入的一端被称为<font color = "CC6600">「队尾」</font>

### <font color = "AA7700">4.2.1 队列的抽象数据类型</font>
```C#
ADT 队列（Queue）
Data
	同线性表。所有的数据元素都是相同的数据类型，相邻的数据元素具有前驱和后继的关系
Operation
	InitQueue()：初始一个空队列
	InitQueue(int capacity)：初始化一个具有初始容量的队列
	EnQueue(T item)：若队列未满，则在队尾插入数据元素
	DeQueue()：若队列中存在数据元素，则将队头元素删除
	PeekQueuej()：读取队头的数据元素，但是并不删除
	IsEmpty()：判断队列是否为空
	ClearQueue()：若队列中存在数据元素，则清空队列
	Dispose()：若队列实例存在，则销毁队列
EndADT
```

### <font color = "AA7700">4.2.2 循环队列</font>
<strong>概念：在队列中，从队头中删除一个数据元素则后面的数据元素都要向前移动一个位置，这样的时间复杂度为O(n)。为了解决这个问题我们引入循环队列，即：设置两个指针front（队头指针）和rear（队尾指针）</strong>
- <font color = "CC6600">「front」</font>指向队首元素，<font color = "CC6600">「rear」</font>指向队尾元素的下一个数组元素（即空闲数组元素）
- front和rear的初始状态都为0
- 当队首（队尾）删除（添加）一个数据元素时则front（rear）向后移动一个位置
- 如果front=\=rear表示队满或对队空，那么我们该如何判断是队满状态还是队空状态呢，这里有以下两个方法（假设front = 0，rear = 0，队列长度queueSize=5）
	- 公式法：(rear+1)%queueSize。如果(rear+1)%queueSize=\=front则表示队列已满，反之未满^[注意，(rear+1)%queueSize == front表示队满状态，rear == front表示队空状态]。
	- 设置标志变量法：我们设置一个标志变量count，它表示队列中实际存储的数据元素。如果count<queueSize则表示队列暂时还没满，如果count = 0，则表示为空队，如果cont >= queueSize则表示队列已满

#### <font color = "DDAA00">4.2.2.1 循环队列的实现代码</font>
```C#
public interface IMyQueue<T>
{
    void EnQueue(T item);
    void Grow();
    T DeQueue();
    T PeekQueue();
    int MoveNext(int rear);
    bool IsEmpty();
    void ClearQueue();
}

using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MyQueue;

public class MyQueue<T> : IMyQueue<T>,IDisposable
{
    private int _front;
    private int _rear;
    private T[] _items;
    private int _count;
    private const int _defaultCapacity = 4;

    public int Count => _count;//返回队列中实际的数据元素

    /// <summary>
    /// 获取或修改当前队列的长度
    /// </summary>
    public int Capacity
    {
        get => _items.Length;
        set
        {
            if (value < 0 || value < _count)
                throw new IndexOutOfRangeException(nameof(Index));

            if (value != _items.Length)
            {
                int front = _front;
                int count = _count;

                T[] items = _items;
                T[] newItems = new T[value];

                if (_count > 0)
                {
                    for (int i = 0; i < count; i++)
                    {
                        newItems[i] = items[front];
                        front = MoveNext(front);
                    }

                    _front = 0;
                    _rear = count;
                    _items = newItems;
                }
                else
                    _items = newItems;
            }
        }
    }

    /// <summary> 初始化一个没有分配内存的空队列
    /// </summary>
    public MyQueue()
    {
        _items = Array.Empty<T>();
        _front = 0;
        _rear = 0;
        _count = 0;
    }

    /// <summary> 初始化一个具有初始容量的队列
    /// </summary>
    /// <param name="capacity">初始容量</param>
    public MyQueue(int capacity)
    {
        _items = new T[capacity];
        _front = 0;
        _rear = 0;
        _count = 0;
    }

    /// <summary> 将数据元素添加到队尾中，如果队列还未分配内存或者队列已满，则进行扩容
    /// </summary>
    /// <param name="item">需要添加的数 据元素</param>
    public void EnQueue(T item)
    {
        if (_items.Length == 0 || MoveNext(_rear) == _front)
            Grow();

        _items[_rear] = item;
        _rear = MoveNext(_rear);
        _count++;
    }

    /// <summary>
    /// 对队列进行扩容操作
    /// </summary>
    public void Grow()
    {
        int capacity = _items.Length == 0 ? _defaultCapacity : _items.Length * 2;
        if (capacity > Array.MaxLength)
            capacity = Array.MaxLength;

        Capacity = capacity;
    }

    /// <summary>
    /// 用于删除队列的头元素
    /// </summary>
    /// <returns>返回被删除的那个数据元素</returns>
    public T DeQueue()
    {
        if(_count == 0)
            ThrowFromEmptyQueue();

        T[] items = _items;
        int front = _front;

        T item = _items[front];
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())//判断T是引用类型还是值类型
            items[front] = default!;

        _front = MoveNext(front);
        _count--;

        return item;
    }

    /// <summary>
    /// 查看队首元素，但是并不移除
    /// </summary>
    /// <returns>返回队首元素</returns>
    public T PeekQueue()
    {
        if(_count == 0)
            ThrowFromEmptyQueue();

        return _items[_front];
    }

    /// <summary>
    /// 计算队尾指针的下一个位置
    /// </summary>
    /// <param name="rear"></param>
    public int MoveNext(int rear)
        => rear = (rear + 1) % _items.Length;

    /// <summary>
    /// 判断队列是否为空
    /// </summary>
    /// <returns>为空返回true，否则返回false</returns>
    public bool IsEmpty()
    {
        if (_items.Length == 0 || _rear == _front)
            return true;

        return false;
    }

    /// <summary>
    /// 如果队列存在数据，则清空队列
    /// </summary>
    public void ClearQueue()
    {
        if(_count == 0)
            ThrowFromEmptyQueue();

        if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            int front = _front;
            int rear = _rear;
            T[] items = _items;

            if (_front < _rear)
            {

                for (int i = front; i < rear; i++)
                    items[i] = default!;
            }
            else
            {
                for (int i = front; i < _items.Length - front; i++)
                    items[i] = default!;
                for (int i = 0; i < rear; i++)
                    items[i] = default!;
            }
        }

        _count = 0;
        _front = 0;
        _rear = 0;
    }

    /// <summary>
    /// 如果队列为空，则抛出异常，如果不为空则触发断言失败
    /// </summary>
    /// <exception cref="InvalidOperationException"></exception>
    private void ThrowFromEmptyQueue()
    {
        Debug.Assert(_count == 0);
        throw new InvalidOperationException();
    }

    /// <summary>
    /// 销毁队列
    /// </summary>
    public void Dispose()
    {
        ClearQueue();
        GC.SuppressFinalize(this);
    }
}

namespace MyQueue
{
    internal class Program
    {
        static void Main(string[] args)
        {
            using MyQueue<int> queue = new();

            Console.Write("通过EnQueue方法添加数据元素：\n");
            for (int i = 1; i <= 12; i++)
                queue.EnQueue(i);

            queue.DeQueue();
            queue.DeQueue();
            queue.DeQueue();

            for (int i = 10; i <= 16; i++)
                queue.EnQueue(i);

            Console.WriteLine($"使用PeekQueue方法查看队首元素：{queue.PeekQueue()}");
            queue.ClearQueue();
        }
    }
}

```

### <font color = "AA7700">4.2.3 队列的链式存储结构</font>
<strong>概念：队列的链式存储结构其实就是线性表的单链表</strong>
- 简称<font color = "CC6600">「链队列」</font>
- 与普通的单链表不同，它只能<font color = "CC6600">「头出尾进」</font>
- 头指针指向头结点
- 尾指针指向终端结点
- 空队时，头指针和尾指针都指向头结点

#### <font color = "DDAA00">4.2.3.1 链队列的实现代码</font>
```C#
public class Node<T>
{
#pragma warning disable CS8618
    public T Data { get; set; }
#pragma warning restore CS8618

    public Node<T>? Next { get; set; }
}

public interface IMyLinkedQueue<T>
{
    void EnQueue(T item);
    bool DeQueue([MaybeNullWhen(false)]out T? item);
    T PeekQueue();
    void ThrowFromEmptyQueue();
    void ClearQueue();
}

public class MyLinkedQueue<T> : IMyLinkedQueue<T>,IDisposable
{
    private readonly Node<T> _headNode = new();
    private readonly Node<T> _rearNode;
    private int _count;

    public MyLinkedQueue()
    {
        _headNode.Next = _headNode;
        _rearNode = new()
        {
            Next = _headNode
        };

        _count = 0;
    }

    public int Count => _count;

    /// <summary>
    /// 添加操作，将数据元素添加到队尾
    /// </summary>
    /// <param name="item">需要添加的数据元素</param>
    /// <exception cref="ArgumentNullException">如果添加的数据元素为空，则抛出异常</exception>
    public void EnQueue(T item)
    {
        if (item is null)
            throw new ArgumentNullException(nameof(item));

        int count = _count;
        Node<T> rearNode = _rearNode;

        Node<T> tailNode = rearNode.Next!;
        Node<T> newNode = new()
        {
            Data = item,
            Next = null
        };
        tailNode.Next = newNode;
        rearNode.Next = newNode;
        _count = ++count;
    }

    /// <summary>
    /// 删除队首数据元素
    /// </summary>
    /// <param name="item">删除的数据元素</param>
    /// <returns>删除成功返回true，否则返回false</returns>
    public bool DeQueue(out T? item)
    {
        if (_headNode.Next!.Equals(_headNode))
            ThrowFromEmptyQueue();

        Node<T> headNode = _headNode;
        Node<T> deNode = headNode.Next!;
        headNode.Next = deNode.Next;

        item = deNode.Data;
        _count--;
        return true;
    }

    /// <summary>
    /// 获取队首的数据元素
    /// </summary>
    /// <returns>返回获取到的数据元素</returns>
    public T PeekQueue()
    {
        if(_headNode.Next!.Equals(_headNode))
            ThrowFromEmptyQueue();

        return _headNode.Next.Data;
    }

    /// <summary>
    /// 如果_count不为0，则断言触发失败，将执行异常
    /// </summary>
    /// <exception cref="InvalidOperationException">如果断言触发失败则抛出异常</exception>
    public void ThrowFromEmptyQueue()
    {
        Debug.Assert(_count == 0);
        throw new InvalidOperationException();
    }

    /// <summary>
    /// 如果队列存在数据元素，则清空
    /// </summary>
    public void ClearQueue()
    {
        if (_headNode.Next!.Equals(_headNode))
            return;

        Node<T> headNode = _headNode;
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            while ((headNode.Next is not null))
            {
                Node<T> deNode = headNode.Next!;
                headNode.Next = deNode.Next;
                deNode = default!;
            }
        }

        _headNode.Next = headNode;
        _rearNode.Next = headNode;
        _count = 0;
    }

    /// <summary>
    /// 销毁队列
    /// </summary>
    public void Dispose()
    {
        ClearQueue();
        GC.SuppressFinalize(this);
    }
}

namespace MyLinkedQueue
{
    internal class Program
    {
        static void Main(string[] args)
        {
            using MyLinkedQueue<int> queue = new();
            for (int i = 1; i <= 5; i++)
                queue.EnQueue(i);

            queue.DeQueue(out int item);
            queue.DeQueue(out int a);
            queue.DeQueue(out int b);

            for (int i = 6; i <= 10; i++)
                queue.EnQueue(i);

            Console.WriteLine($"利用PeekQueue方法获取队首元素：{queue.PeekQueue()}");
            queue.ClearQueue();
        }
    }
}
```
## <font color = "886600">4.3 总结</font>
![第四章 栈与队列.png](https://raw.githubusercontent.com/Altholia/CodeNotesPicGo/main/202309161225088.png)
